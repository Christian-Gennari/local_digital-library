// src/utils/epubToc.ts

/**
 * Normalized Table of Contents item used by the reader.
 * - `id` is guaranteed to exist (autogenerated if missing)
 * - `level` starts at 1 for top-level entries
 */
export interface TocItem {
  id: string;
  label?: string;
  href?: string;
  level: number;
  subitems?: TocItem[];
}

/**
 * Minimal information we need from an EPUB section or location
 * to match it to a ToC node.
 */
export interface SectionRef {
  idref?: string | null;
  href?: string | null;
}

/**
 * Location shape typically emitted by rendition.on("relocated", loc)
 * We only rely on `start.href` (safest/most portable).
 */
export interface EpubLocationLike {
  start?: {
    href?: string;
    cfi?: string;
    index?: number;
  };
  end?: {
    href?: string;
    cfi?: string;
    index?: number;
  };
  index?: number;
}

/* -------------------------------------------------------------------------------------------------
 * Normalization helpers
 * ------------------------------------------------------------------------------------------------- */

const stripAfter = (s: string, char: string) =>
  s.includes(char) ? s.slice(0, s.indexOf(char)) : s;

/**
 * Normalize an href for robust comparisons:
 * - remove hash and query parts
 * - decode URI if possible
 * - trim leading "./" and leading "/" (since some readers vary)
 * - collapse multiple slashes
 * - lower-case (file systems differ; EPUB assets are usually case-consistent, but be defensive)
 */
export const normalizeHref = (href?: string): string => {
  if (!href) return "";
  let out = href.trim();
  out = stripAfter(out, "#");
  out = stripAfter(out, "?");
  try {
    out = decodeURI(out);
  } catch {
    // ignore decoding errors, keep raw
  }
  // Remove "./" and leading "/" to compare relative forms uniformly
  out = out.replace(/^\.\//, "").replace(/^\/+/, "");
  // Collapse duplicate slashes inside path
  out = out.replace(/\/{2,}/g, "/");
  // Normalize case for comparison (safe for file names; anchors already stripped)
  out = out.toLowerCase();
  return out;
};

/**
 * Flexible href match:
 *  - normalized equality
 *  - substring inclusion either way (to tolerate reader-produced variants)
 */
export const hrefMatches = (a?: string | null, b?: string | null): boolean => {
  const A = normalizeHref(a || undefined);
  const B = normalizeHref(b || undefined);
  if (!A || !B) return false;
  return A === B || A.includes(B) || B.includes(A);
};

/* -------------------------------------------------------------------------------------------------
 * ToC building & search utilities
 * ------------------------------------------------------------------------------------------------- */

/**
 * Ensure every ToC item has an id and a level; deep clone w/ normalization.
 */
export const generateTocItems = (toc: any[], level = 1): TocItem[] => {
  if (!Array.isArray(toc)) return [];
  return toc.map((ch: any, i: number): TocItem => {
    const node: TocItem = {
      id: ch?.id || `chapter-${level}-${i}`,
      label: ch?.label ?? ch?.title ?? "Untitled Chapter",
      href: ch?.href ?? ch?.content ?? ch?.url, // be forgiving about source fields
      level,
      subitems: ch?.subitems
        ? generateTocItems(ch.subitems, level + 1)
        : ch?.subchapters
        ? generateTocItems(ch.subchapters, level + 1)
        : [],
    };
    return node;
  });
};

/**
 * Depth-first search by id.
 */
export const findById = (
  toc: TocItem[],
  id?: string | null
): TocItem | null => {
  if (!id) return null;
  const stack = [...toc];
  while (stack.length) {
    const node = stack.shift()!;
    if (node.id === id) return node;
    if (node.subitems?.length) stack.unshift(...node.subitems);
  }
  return null;
};

/**
 * Depth-first search by href (normalized).
 */
export const findByHref = (
  toc: TocItem[],
  href?: string | null
): TocItem | null => {
  if (!href) return null;
  const stack = [...toc];
  while (stack.length) {
    const node = stack.shift()!;
    if (node.href && hrefMatches(node.href, href)) return node;
    if (node.subitems?.length) stack.unshift(...node.subitems);
  }
  return null;
};

/**
 * Get a flat list of all ToC items. Useful for indexing or quick scans.
 */
export const flattenToc = (toc: TocItem[]): TocItem[] => {
  const out: TocItem[] = [];
  const stack = [...toc];
  while (stack.length) {
    const node = stack.shift()!;
    out.push(node);
    if (node.subitems?.length) stack.unshift(...node.subitems);
  }
  return out;
};

/**
 * Compute the full parent path (IDs) to an item, inclusive of the item itself.
 * Useful to auto-expand ancestors in a nested ToC UI.
 */
export const findParentPath = (toc: TocItem[], targetId: string): string[] => {
  const path: string[] = [];
  const dfs = (nodes: TocItem[], parents: string[]): boolean => {
    for (const n of nodes) {
      const current = [...parents, n.id];
      if (n.id === targetId) {
        path.push(...current);
        return true;
      }
      if (n.subitems?.length && dfs(n.subitems, current)) return true;
    }
    return false;
  };
  dfs(toc, []);
  return path;
};

/* -------------------------------------------------------------------------------------------------
 * Matching: Section/Location -> ToC
 * ------------------------------------------------------------------------------------------------- */

/**
 * Match a section (idref/href) to the best ToC entry.
 * Strategy:
 *  1) Try idref (fast, precise) if your ToC ids carry spine ids.
 *  2) Fall back to href (robust with our normalization and inclusion logic).
 */
export const matchSectionToToc = (
  toc: TocItem[],
  section: SectionRef | null | undefined
): TocItem | null => {
  if (!toc?.length || !section) return null;
  return findById(toc, section.idref) || findByHref(toc, section.href);
};

/**
 * Convenience: resolve human-readable chapter name (or a safe fallback).
 */
export const chapterNameFromSection = (
  toc: TocItem[],
  section: SectionRef | null | undefined
): string => matchSectionToToc(toc, section)?.label || "Unknown Chapter";

/**
 * Extract a SectionRef from a rendition "relocated" location.
 * We prefer `start.href` because it aligns with actual document assets.
 */
export const sectionRefFromLocation = (
  location: EpubLocationLike | null | undefined
): SectionRef => {
  const href = location?.start?.href ?? location?.end?.href ?? null;
  // We usually *don't* have idref here without consulting the spine,
  // so we return only href; matchSectionToToc will fall back to href matching.
  return { idref: null, href };
};

/**
 * Directly match a location to the ToC.
 */
export const matchLocationToToc = (
  toc: TocItem[],
  location: EpubLocationLike | null | undefined
): TocItem | null => {
  return matchSectionToToc(toc, sectionRefFromLocation(location));
};
